caption = "Jennifer Lopes.")
print(croqui)
mod.fg <- lmer(prod ~ gen + rep + (1 | rep:inc.bloco), data = dados)
plot(resid(mod.fg) ~ fitted(mod.fg),
main = "Resíduos vs Ajustados - Modelo Fixo (BLUE)")
qqnorm(resid(mod.fg)); qqline(resid(mod.fg))
anova_fg <- anova(mod.fg, ddf = "Kenward-Roger")
anova_fg
mod.rg <- lmer(prod ~ rep + (1 | gen) + (1 | rep:inc.bloco), data = dados)
plot(resid(mod.rg) ~ fitted(mod.rg), main = "Resíduos vs Ajustados - Modelo Aleatório (BLUP)")
ranova_rg <- ranova(mod.rg)
ranova_rg
aic_comp <- data.frame(
Modelo = c("Efeito Fixo (BLUE)", "Efeito Aleatório (BLUP)"),
AIC = c(AIC(mod.fg), AIC(mod.rg)),
logLik = c(logLik(mod.fg), logLik(mod.rg))
)
print(aic_comp)
mod.rg <- lmer(prod ~ rep + (1 | gen) + (1 | rep:inc.bloco), data = dados)
plot(resid(mod.rg) ~ fitted(mod.rg), main = "Resíduos vs Ajustados - Modelo Aleatório (BLUP)")
qqnorm(resid(mod.rg)); qqline(resid(mod.rg))
ranova_rg <- ranova(mod.rg)
ranova_rg
aic_comp <- data.frame(
Modelo = c("Efeito Fixo (BLUE)", "Efeito Aleatório (BLUP)"),
AIC = c(AIC(mod.fg), AIC(mod.rg)),
logLik = c(logLik(mod.fg), logLik(mod.rg))
)
print(aic_comp)
BLUEs <- emmeans::emmeans(mod.fg, ~ gen) %>%
as.data.frame() %>%
transmute(gen, BLUE = emmean, IC_inferior = lower.CL, IC_superior = upper.CL)
DT::datatable(BLUEs)
DT::datatable(BLUEs)
dados <- coleta_dados_github(
repo = "whussain2/Mixed_Models",
path = "Mixed_Models/Data/australia.soybean.csv")
coleta_dados_github <- function(repo, path, branch = "main", token = Sys.getenv("GITHUB_TOKEN")) {
library(httr2)
library(readr)
library(readxl)
library(base64enc)
library(glue)
# Mensagem de debug
message(glue("Conectando ao repositório {repo}, arquivo: {path}"))
# Monta a URL da API
url <- paste0("https://api.github.com/repos/", repo, "/contents/", path, "?ref=", branch)
# Requisição
req <- request(url)
if (nzchar(token)) {
req <- req_auth_bearer_token(req, token)
}
# Executa a requisição
resp <- req_perform(req)
# Se falhar, mostra status
if (resp_status(resp) >= 300) {
stop(glue("Falha ao acessar GitHub: HTTP {resp_status(resp)}. Verifique o token, repo e caminho."))
}
obj <- resp_body_json(resp)
if (is.null(obj$content)) {
stop("Conteúdo vazio verifique se o caminho aponta para um arquivo, não para uma pasta.")
}
# Decodifica o arquivo em base64
raw <- base64decode(obj$content)
ext <- tools::file_ext(path)
tmp <- tempfile(fileext = paste0(".", ext))
writeBin(raw, tmp)
# Lê conforme o tipo
if (ext == "csv") {
dados <- read_csv(tmp, show_col_types = FALSE)
} else if (ext %in% c("xlsx", "xls")) {
dados <- read_excel(tmp)
} else {
stop("Formato não suportado: use .csv, .xlsx ou .xls")
}
message(glue("Dados carregados com sucesso ({nrow(dados)} linhas, {ncol(dados)} colunas)."))
return(dados)
}
# Carrega a função de coleta de dados (salva em funcoes/coleta_dados_github.R)
source("meu_projeto/funcoes/coleta_dados_github.R")
# Coleta dos dados direto do repositório público
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
dados <- coleta_dados_github(
repo = "whussain2/Mixed_Models",
path = "Mixed_Models/Data/australia.soybean.csv")
dados <- coleta_dados_github(
repo = "rfordatascience/tidytuerday",
path = "data/2025/2025-11-18/who_tb_data.csv")
cafe <- coleta_dados_github(
repo = "rfordatascience/tidytuesday",
path = "data/2020/2020-07-07/coffee_ratings.csv"
)
dados2 <- coleta_dados_github(
repo = "rfordatascience/tidytuersday",
path = "data/2025/2025-11-18/who_tb_data.csv")
dados2 <- coleta_dados_github(
repo = "rfordatascience/tidytuesday",
path = "data/2025/2025-11-18/who_tb_data.csv"
)
View(dados2)
# Coleta dos dados direto do repositório público
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
dados <- dados %>%
mutate(
gen = as.factor(gen),
rep = as.factor(rep),
inc.bloco = as.factor(inc.bloco))
resumo <- dados %>%
summarise(
n_genotipos   = n_distinct(gen),
n_repeticoes  = n_distinct(rep),
n_blocos_inc      = n_distinct(inc.bloco))
print(resumo)
anova_fg <- anova(mod.fg, ddf = "Kenward-Roger")
anova_fg
BLUEs <- emmeans::emmeans(mod.fg, ~ gen) %>%
as.data.frame() %>%
transmute(gen, BLUE = emmean, IC_inferior = lower.CL, IC_superior = upper.CL)
DT::datatable(BLUEs)
# Junta as estimativas dos dois modelos pelo identificador gen
comparacao <- full_join(BLUEs, BLUPs, by = "gen", suffix = c("_BLUE", "_BLUP"))
mu_manual <- fixef(mod.rg)[1]
BLUPs <- augment(ranef(mod.rg)) %>%
filter(grp == "gen") %>%
transmute(gen = level,
BLUP = mu_manual + estimate,
IC_inferior = BLUP - 1.96 * std.error,
IC_superior = BLUP + 1.96 * std.error)
# Junta as estimativas dos dois modelos pelo identificador gen
comparacao <- full_join(BLUEs, BLUPs, by = "gen", suffix = c("_BLUE", "_BLUP"))
# Reestrutura os dados para formato longo
comparacao_long <- comparacao %>%
pivot_longer(
cols = c(BLUE, BLUP),
names_to = "Tipo",
values_to = "Estimativa"
)
# Ordena os genótipos pela média BLUP
ordem_gen <- comparacao %>%
arrange(BLUP) %>%
pull(gen)
comparacao_long$gen <- factor(comparacao_long$gen, levels = ordem_gen)
# Gera o gráfico comparativo
ggplot(comparacao_long, aes(x = gen, y = Estimativa, fill = Tipo)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8), color = "black") +
geom_errorbar(aes(
ymin = ifelse(Tipo == "BLUE", IC_inferior_BLUE, IC_inferior_BLUP),
ymax = ifelse(Tipo == "BLUE", IC_superior_BLUE, IC_superior_BLUP)
), position = position_dodge(width = 0.8), width = 0.25) +
labs(
title = "Comparação entre BLUEs e BLUPs por Genótipo",
x = "Genótipos",
y = "Estimativas (Produção Ajustada)",
fill = "Modelo"
) +
theme_minimal(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5)
)
# Junta as estimativas dos dois modelos pelo identificador gen
comparacao <- full_join(BLUEs, BLUPs, by = "gen", suffix = c("_BLUE", "_BLUP"))
# Reestrutura os dados para formato longo
comparacao_long <- comparacao %>%
pivot_longer(
cols = c(BLUE, BLUP),
names_to = "Tipo",
values_to = "Estimativa")
# Ordena os genótipos pela média BLUP
ordem_gen <- comparacao %>%
arrange(BLUP) %>%
pull(gen)
comparacao_long$gen <- factor(comparacao_long$gen,
levels = ordem_gen)
# Gera o gráfico
ggplot(comparacao_long, aes(x = gen, y = Estimativa, fill = Tipo)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8), color = "black") +
geom_errorbar(aes(
ymin = ifelse(Tipo == "BLUE", IC_inferior_BLUE,
IC_inferior_BLUP),
ymax = ifelse(Tipo == "BLUE", IC_superior_BLUE,
IC_superior_BLUP)),
position = position_dodge(width = 0.8), width = 0.25) +
labs(
title = "Comparação entre BLUEs e BLUPs por Genótipo",
x = "Genótipos",
y = "Estimativas (Produção Ajustada)",
fill = "Modelo") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
# Gera o gráfico
ggplot(comparacao_long, aes(x = gen, y = Estimativa, fill = Tipo)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8), color = "black") +
geom_errorbar(aes(
ymin = ifelse(Tipo == "BLUE", IC_inferior_BLUE,
IC_inferior_BLUP),
ymax = ifelse(Tipo == "BLUE", IC_superior_BLUE,
IC_superior_BLUP)),
position = position_dodge(width = 0.8), width = 0.25) +
labs(
title = "Comparação entre BLUEs e BLUPs por Genótipo",
x = "Genótipos",
y = "Estimativas de produção",
fill = "Modelo") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
# Ordena os genótipos pela estimativa BLUP
BLUPs <- BLUPs %>%
arrange(BLUP) %>%
mutate(gen = factor(gen, levels = gen))
# Gera o gráfico
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
labs(
title = "Estimativas BLUPs por Genótipo",
x = "Genótipos",
y = "Produtividade Ajustada (kg/ha)"
) +
theme_minimal(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5)
)
# Gera o gráfico
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
labs(
title = "Estimativas BLUPs por Genótipo",
x = "Genótipos",
y = "Produtividade (kg/ha)") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
# Gera o gráfico
ggplot(comparacao_long, aes(x = gen, y = Estimativa, fill = Tipo)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8), color = "black") +
geom_errorbar(aes(
ymin = ifelse(Tipo == "BLUE", IC_inferior_BLUE,
IC_inferior_BLUP),
ymax = ifelse(Tipo == "BLUE", IC_superior_BLUE,
IC_superior_BLUP)),
position = position_dodge(width = 0.8), width = 0.25) +
labs(
title = "Comparação entre BLUEs e BLUPs por Genótipo",
x = "Genótipos",
y = "Estimativas de produção",
fill = "Modelo") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
# Ordena os genótipos pela estimativa BLUP
BLUPs <- BLUPs %>%
arrange(BLUP) %>%
mutate(gen = factor(gen, levels = gen))
# Gera o gráfico
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
labs(
title = "Estimativas BLUPs por Genótipo",
x = "Genótipos",
y = "Produtividade (kg/ha)") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
media_geral <- fixef(mod.rg)[1]
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
geom_hline(yintercept = media_geral,
color = "#E85D04", linetype = "dashed", size = 1) +
annotate("text",
x = Inf, y = media_geral,
label = paste0("Média geral = ", round(media_geral, 2)),
hjust = 1.1, vjust = -0.5, color = "#E85D04", size = 3.5) +
labs(
title = "Estimativas BLUPs por Genótipo",
subtitle = "Linha tracejada indica a média geral ajustada (μ)",
x = "Genótipos",
y = "Produtividade (kg/ha)"
) +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5)
)
media_geral <- fixef(mod.rg)[1]
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
geom_hline(yintercept = media_geral,
color = "#E85D04", linetype = "dashed", size = 1) +
annotate("text",
x = Inf, y = media_geral,
label = paste0("Média geral = ", round(media_geral, 2)),
hjust = 1.1, vjust = -0.5, color = "#E85D04", size = 3.5) +
labs(
title = "Estimativas BLUPs por Genótipo",
subtitle = "Linha tracejada indica a média geral ajustada (μ)",
x = "Genótipos",
y = "Produtividade (kg/ha)"
) +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5)
)
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
geom_hline(yintercept = media_geral,
color = "#E85D04", linetype = "dashed", size = 1) +
annotate("text",
x = Inf, y = media_geral,
label = paste0("Média geral = ", round(media_geral, 2)),
hjust = 1.1, vjust = -0.5, color = "#E85D04", size = 3.5) +
labs(
title = "Estimativas BLUPs por Genótipo",
subtitle = "Linha tracejada indica a média geral ajustada (μ)",
x = "Genótipos",
y = "Produtividade (kg/ha)") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
ggplot(BLUPs, aes(x = gen, y = BLUP)) +
geom_bar(stat = "identity", fill = "#2ca9b7", color = "black", width = 0.7) +
geom_errorbar(aes(ymin = IC_inferior, ymax = IC_superior), width = 0.2) +
geom_hline(yintercept = media_geral,
color = "#E85D04", linetype = "dashed", size = 1)+
labs(
title = "Estimativas BLUPs por Genótipo",
subtitle = "Linha tracejada indica a média geral ajustada (μ)",
x = "Genótipos",
y = "Produtividade (kg/ha)") +
theme_classic(base_size = 12) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5))
blup_values <- BLUPs$BLUP
names(blup_values) <- BLUPs$gen
dist_blups <- dist(blup_values, method = "euclidean")
hc <- hclust(dist_blups, method = "average")
plot(hc, main = "Dendrograma UPGMA - BLUPs",
xlab = "Genótipos", ylab = "Distância Euclidiana")
vcomps <- as.data.frame(VarCorr(mod.rg))
vc.g <- vcomps[vcomps$grp == "gen", "vcov"]
vc.e <- vcomps[vcomps$grp == "Residual", "vcov"]
nreps <- 3
hc <- as.numeric(vc.g / (vc.g + vc.e / nreps))  # <- garante tipo numérico
print(glue::glue("Herdabilidade estimada: {round(hc, 3)}"))
plot(hc, main = "Dendrograma UPGMA - BLUPs",
xlab = "Genótipos", ylab = "Distância Euclidiana")
blup_values <- BLUPs$BLUP
names(blup_values) <- BLUPs$gen
dist_blups <- dist(blup_values, method = "euclidean")
hc <- hclust(dist_blups, method = "average")
plot(hc, main = "Dendrograma UPGMA - BLUPs",
xlab = "Genótipos", ylab = "Distância Euclidiana")
# Correlação cofenética
cophenetic_dist <- cophenetic(hc)
correlation_cophenetic <- cor(dist_blups, cophenetic_dist)
print(paste("Correlação cofenética:", round(correlation_cophenetic, 4)))
library(here)
here::here()
fs::dir_tree(here::here())
fs::dir_tree(here::here())
fs::dir_tree(here::here())
fs::dir_tree(here::here())
# Carrega a função de coleta de dados (salva em funcoes/coleta_dados_github.R)
source("meu_projeto/funcoes/coleta_dados_github.R")
# Coleta dos dados direto do repositório público
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
coleta_dados_github <- function(repo, path, branch = "main", token = Sys.getenv("GITHUB_TOKEN")) {
library(httr2)
library(readr)
library(readxl)
library(base64enc)
library(glue)
# Mensagem de debug
message(glue("Conectando ao repositório {repo}, arquivo: {path}"))
# Monta a URL da API
url <- paste0("https://api.github.com/repos/", repo, "/contents/", path, "?ref=", branch)
# Requisição
req <- request(url)
if (nzchar(token)) {
req <- req_auth_bearer_token(req, token)
}
# Executa a requisição
resp <- req_perform(req)
# Se falhar, mostra status
if (resp_status(resp) >= 300) {
stop(glue("Falha ao acessar GitHub: HTTP {resp_status(resp)}. Verifique o token, repo e caminho."))
}
obj <- resp_body_json(resp)
if (is.null(obj$content)) {
stop("Conteúdo vazio verifique se o caminho aponta para um arquivo, não para uma pasta.")
}
# Decodifica o arquivo em base64
raw <- base64decode(obj$content)
ext <- tools::file_ext(path)
tmp <- tempfile(fileext = paste0(".", ext))
writeBin(raw, tmp)
# Lê conforme o tipo
if (ext == "csv") {
dados <- read_csv(tmp, show_col_types = FALSE)
} else if (ext %in% c("xlsx", "xls")) {
dados <- read_excel(tmp)
} else {
stop("Formato não suportado: use .csv, .xlsx ou .xls")
}
message(glue("Dados carregados com sucesso ({nrow(dados)} linhas, {ncol(dados)} colunas)."))
return(dados)
}
# Carrega a função de coleta de dados (salva em funcoes/coleta_dados_github.R)
source("meu_projeto/funcoes/coleta_dados_github.R")
# Coleta dos dados direto do repositório público
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
broom,          # Organiza resultados de modelos em formato tidy
broom.mixed,    # Versão do broom para modelos mistos
desplot,        # Visualiza delineamentos experimentais
emmeans,        # Médias ajustadas e comparações múltiplas
ggpubr,         # Gráficos estatísticos prontos com ggplot2
lme4,           # Modelos lineares mistos
lmerTest,       # P-valores para modelos lmer()
multcomp,       # Testes múltiplos (Tukey, Dunnett)
multcompView,   # Letras de agrupamento (a, b, c)
plotly,         # Gráficos interativos
tidyverse,      # Conjunto para manipulação e visualização de dados
writexl,        # Exporta dados para Excel
metan,          # Análises agronômicas e genéticas (BLUP, MGIDI)
httr2,          # Consumo de APIs modernas
readr,          # Leitura rápida de CSV e textos
readxl,         # Importação de planilhas Excel
base64enc,       # Codificação Base64 (arquivos e APIs)
viridis,
DT,
tidyr)
coleta_dados_github <- function(repo, path, branch = "main", token = Sys.getenv("GITHUB_TOKEN")) {
library(httr2)
library(readr)
library(readxl)
library(base64enc)
library(glue)
# Mensagem de debug
message(glue("Conectando ao repositório {repo}, arquivo: {path}"))
# Monta a URL da API
url <- paste0("https://api.github.com/repos/", repo, "/contents/", path, "?ref=", branch)
# Requisição
req <- request(url)
if (nzchar(token)) {
req <- req_auth_bearer_token(req, token)
}
# Executa a requisição
resp <- req_perform(req)
# Se falhar, mostra status
if (resp_status(resp) >= 300) {
stop(glue("Falha ao acessar GitHub: HTTP {resp_status(resp)}. Verifique o token, repo e caminho."))
}
obj <- resp_body_json(resp)
if (is.null(obj$content)) {
stop("Conteúdo vazio verifique se o caminho aponta para um arquivo, não para uma pasta.")
}
# Decodifica o arquivo em base64
raw <- base64decode(obj$content)
ext <- tools::file_ext(path)
tmp <- tempfile(fileext = paste0(".", ext))
writeBin(raw, tmp)
# Lê conforme o tipo
if (ext == "csv") {
dados <- read_csv(tmp, show_col_types = FALSE)
} else if (ext %in% c("xlsx", "xls")) {
dados <- read_excel(tmp)
} else {
stop("Formato não suportado: use .csv, .xlsx ou .xls")
}
message(glue("Dados carregados com sucesso ({nrow(dados)} linhas, {ncol(dados)} colunas)."))
return(dados)
}
# Carrega a função de coleta de dados (salva em funcoes/coleta_dados_github.R)
source("meu_projeto/funcoes/coleta_dados_github.R")
# Coleta dos dados direto do repositório público
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
# Carrega a função de coleta de dados (salva em funcoes/coleta_dados_github.R)
source("meu_projeto/funcoes/coleta_dados_github.R")
# Coleta dos dados direto do repositório público
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
# Visualiza estrutura do dataset
glimpse(dados)
