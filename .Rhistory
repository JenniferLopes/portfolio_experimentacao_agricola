)
croqui <- dados %>%
ggplot(aes(x = col, y = row, fill = inc.bloco)) +
geom_tile(color = "black") +
geom_text(aes(label = gen), size = 3) +
theme_bw() +
facet_wrap(~ rep, scales = "free_x") +
labs(
title = "Croqui de Campo - Portif√≥lio",
x = "Colunas",
y = "Linhas"
)
print(croqui)
dados %>%
metan::desc_stat(prod, hist = TRUE, stats = "main")
# ============================================================
# MODELO 1: Gen√≥tipo como efeito fixo  ‚Üí BLUEs
# ============================================================
mod.fg <- lmer(prod ~ gen + rep + (1 | rep:inc.bloco), data = dados)
# Diagn√≥stico de res√≠duos
plot(resid(mod.fg) ~ fitted(mod.fg),
main = "Res√≠duos vs Ajustados - Modelo Fixo (BLUE)")
qqnorm(resid(mod.fg)); qqline(resid(mod.fg))
# ANOVA para efeitos fixos
anova_fg <- anova(mod.fg, ddf = "Kenward-Roger")
anova_fg
# ============================================================
# MODELO 2: Gen√≥tipo como efeito aleat√≥rio  ‚Üí BLUPs
# ============================================================
mod.rg <- lmer(prod ~ rep + (1 | gen) + (1 | rep:inc.bloco), data = dados)
# Diagn√≥stico de res√≠duos
plot(resid(mod.rg) ~ fitted(mod.rg),
main = "Res√≠duos vs Ajustados - Modelo Aleat√≥rio (BLUP)")
qqnorm(resid(mod.rg)); qqline(resid(mod.rg))
# Teste de signific√¢ncia dos componentes de vari√¢ncia
ranova_rg <- ranova(mod.rg)
ranova_rg
# ============================================================
# COMPARA√á√ÉO ENTRE MODELOS (AIC e LogLik)
# ============================================================
aic_comp <- data.frame(
Modelo = c("Efeito Fixo (BLUE)", "Efeito Aleat√≥rio (BLUP)"),
AIC = c(AIC(mod.fg), AIC(mod.rg)),
logLik = c(logLik(mod.fg), logLik(mod.rg))
)
print(aic_comp)
# BLUEs (efeitos fixos)
BLUEs <- emmeans::emmeans(mod.fg, ~ gen) %>%
as.data.frame() %>%
transmute(gen, BLUE = emmean, IC_inferior = lower.CL, IC_superior = upper.CL)
# BLUPs (efeitos aleat√≥rios)
mu_manual <- fixef(mod.rg)[1]
BLUPs <- augment(ranef(mod.rg)) %>%
filter(grp == "gen") %>%
transmute(gen = level,
BLUP = mu_manual + estimate,
IC_inferior = BLUP - 1.96 * std.error,
IC_superior = BLUP + 1.96 * std.error)
comparacao <- full_join(BLUEs, BLUPs, by = "gen", suffix = c("_BLUE", "_BLUP")) %>%
pivot_longer(cols = c(BLUE, BLUP),
names_to = "Tipo",
values_to = "Estimativa")
# Ordena gen√≥tipos pela m√©dia BLUP
comparacao$gen <- factor(comparacao$gen,
levels = comparacao$gen[order(comparacao$Estimativa)])
ggplot(comparacao, aes(x = gen, y = Estimativa, fill = Tipo)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8), color = "black") +
geom_errorbar(aes(
ymin = ifelse(Tipo == "BLUE", IC_inferior_BLUE, IC_inferior_BLUP),
ymax = ifelse(Tipo == "BLUE", IC_superior_BLUE, IC_superior_BLUP)
), position = position_dodge(width = 0.8), width = 0.2) +
labs(
title = "Compara√ß√£o entre BLUEs e BLUPs por Gen√≥tipo",
x = "Gen√≥tipos",
y = "Estimativas (Produ√ß√£o Ajustada)",
fill = "Modelo"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
vcomps <- as.data.frame(VarCorr(mod.rg))
vc.g <- vcomps[vcomps$grp == "gen", "vcov"]
vc.e <- vcomps[vcomps$grp == "Residual", "vcov"]
nreps <- 3
hc <- vc.g / (vc.g + vc.e / nreps)
print(glue::glue("üìà Herdabilidade estimada: {round(hc, 3)}"))
blup_values <- BLUPs$BLUP
names(blup_values) <- BLUPs$gen
dist_blups <- dist(blup_values, method = "euclidean")
hc <- hclust(dist_blups, method = "average")
plot(hc, main = "Dendrograma UPGMA - BLUPs",
xlab = "Gen√≥tipos", ylab = "Dist√¢ncia Euclidiana")
# Correla√ß√£o cofen√©tica
cophenetic_dist <- cophenetic(hc)
correlation_cophenetic <- cor(dist_blups, cophenetic_dist)
print(paste("Correla√ß√£o cofen√©tica:", round(correlation_cophenetic, 4)))
resumo_final <- tibble::tibble(
Modelo_BLUE_AIC = AIC(mod.fg),
Modelo_BLUP_AIC = AIC(mod.rg),
Herdabilidade = round(hc, 3),
Cor_BLUE_BLUP = cor(BLUEs$BLUE, BLUPs$BLUP)
)
print(resumo_final)
cat("
‚úÖ Pipeline completo executado com sucesso.
- Dados importados via API GitHub
- Modelos BLUE e BLUP ajustados
- Herdabilidade e agrupamento estimados
- Compara√ß√£o visual gerada
Autora: Jennifer Luz Lopes | 2025
")
# 1. Carregar o pacote principal ----------------------------------------------
# O {targets} gerencia pipelines reprodut√≠veis e autom√°ticos no R.
library(targets)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# 1. Carregar o pacote principal ----------------------------------------------
# O {targets} gerencia pipelines reprodut√≠veis e autom√°ticos no R.
library(targets)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
fs::dir_tree(here::here())       # Visualiza toda a √°rvore de diret√≥rios
library(targets)
library(tarchetypes)
library(tidyverse)
library(lme4)
library(emmeans)
library(metan)
library(ggplot2)
library(glue)
library(readxl)
library(broom.mixed)
# Configura op√ß√µes globais do pipeline
tar_option_set(
packages = c(
"tidyverse", "lme4", "emmeans", "metan", "ggplot2",
"readxl", "broom.mixed", "glue"
),
format = "rds"
)
# ----------------------------------------------------------------------
# 1. FUN√á√ïES AUXILIARES ------------------------------------------------
# ----------------------------------------------------------------------
source("meu_projeto/funcoes/coleta_dados_github.R")
list(
# Etapa 1: Coleta de dados
tar_target(
dados_brutos,
coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx"
)
),
# Etapa 2: Ajuste de vari√°veis
tar_target(
dados,
dados_brutos %>%
mutate(
gen = as.factor(gen),
rep = as.factor(rep),
inc.bloco = as.factor(inc.bloco)
)
),
# Etapa 3: Modelos BLUE e BLUP
tar_target(
modelo_BLUE,
lmer(prod ~ gen + rep + (1 | rep:inc.bloco), data = dados)
),
tar_target(
modelo_BLUP,
lmer(prod ~ rep + (1 | gen) + (1 | rep:inc.bloco), data = dados)
),
# Etapa 4: Estimativas BLUEs e BLUPs
tar_target(
estimativas,
{
BLUEs <- emmeans(modelo_BLUE, ~ gen) %>%
as.data.frame() %>%
transmute(gen, BLUE = emmean)
mu_manual <- fixef(modelo_BLUP)[1]
BLUPs <- augment(ranef(modelo_BLUP)) %>%
filter(grp == "gen") %>%
transmute(gen = level, BLUP = mu_manual + estimate)
merge(BLUEs, BLUPs, by = "gen")
}
),
# Etapa 5: Herdabilidade
tar_target(
herdabilidade,
{
vcomps <- as.data.frame(VarCorr(modelo_BLUP))
vc.g <- vcomps[vcomps$grp == "gen", "vcov"]
vc.e <- vcomps[vcomps$grp == "Residual", "vcov"]
nreps <- 3
hc <- vc.g / (vc.g + vc.e / nreps)
hc
}
),
# Etapa 6: Agrupamento UPGMA
tar_target(
agrupamento,
{
blup_values <- estimativas$BLUP
names(blup_values) <- estimativas$gen
hc <- hclust(dist(blup_values), method = "average")
hc
}
),
# Etapa 7: Gr√°fico comparativo
tar_target(
grafico_BLUE_BLUP,
{
ggplot(estimativas, aes(x = BLUE, y = BLUP)) +
geom_point(size = 3, alpha = 0.6) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
stat_regline_equation() +
theme_bw() +
labs(
title = "Correla√ß√£o BLUE vs BLUP",
x = "BLUE (Efeito Fixo)",
y = "BLUP (Efeito Aleat√≥rio)"
)
}
),
# Etapa 8: Exporta√ß√£o dos resultados
tar_target(
resumo_final,
{
tibble(
Herdabilidade = round(herdabilidade, 3),
Cor_BLUE_BLUP = cor(estimativas$BLUE, estimativas$BLUP)
)
}
)
)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
Sys.getenv("GITHUB_TOKEN")
source("meu_projeto/funcoes/coleta_dados_github.R")
source("meu_projeto/funcoes/coleta_dados_github.R")
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
dados <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx")
dplyr::glimpse(dados)
list(
# Etapa 1: Coleta de dados
tar_target(
dados_brutos,
coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx"
)
),
source("meu_projeto/funcoes/coleta_dados_github.R")
# Etapa 2: Ajuste de vari√°veis
tar_target(
source("meu_projeto/funcoes/coleta_dados_github.R")
dados_teste <- coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx"
)
coleta_dados_github <- function(repo, path, branch = "main", token = Sys.getenv("GITHUB_TOKEN")) {
library(httr2)
library(readr)
library(readxl)
library(base64enc)
library(glue)
>
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# BLUEs (efeitos fixos)
BLUEs <- emmeans::emmeans(mod.fg, ~ gen) %>%
as.data.frame() %>%
transmute(gen, BLUE = emmean, IC_inferior = lower.CL, IC_superior = upper.CL)
# BLUPs (efeitos aleat√≥rios)
mu_manual <- fixef(mod.rg)[1]
BLUPs <- augment(ranef(mod.rg)) %>%
filter(grp == "gen") %>%
transmute(gen = level,
BLUP = mu_manual + estimate,
IC_inferior = BLUP - 1.96 * std.error,
IC_superior = BLUP + 1.96 * std.error)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# 3. Ver manifesto do pipeline -------------------------------------------------
# Exibe o nome de cada target e o comando usado para ger√°-lo.
tar_manifest(fields = command)
# 4. Visualizar a rede de depend√™ncias ----------------------------------------
# Mostra graficamente como os targets se conectam (interativo).
tar_visnetwork()
# 5. Ler o resultado de um target ---------------------------------------------
# Retorna o conte√∫do direto do target (sem carregar no ambiente).
resultado <- tar_read(herdabilidade)
head(resultado)
# 6. Carregar target no ambiente do RStudio -----------------------------------
# Disponibiliza o objeto para uso manual, como se tivesse sido criado no script.
tar_load(herdabilidade)
View(descritiva_total)
View(herdabilidade)
# 7. Carregar m√∫ltiplos targets de uma s√≥ vez ---------------------------------
# √ötil quando voc√™ quer analisar diferentes etapas ao mesmo tempo.
tar_load(c(resumo_final, estimativas))
View(resumo_final)
# 8. Verificar avisos (warnings) dos targets ----------------------------------
# Mostra quais etapas geraram mensagens de aviso durante a execu√ß√£o.
targets::tar_meta(fields = warnings, complete_only = TRUE)
# 9. Acessar metadados dos targets, como tempo de execu√ß√£o, tamanho, avisos ----
tar_meta()
# 10. Resumo do progresso -------------------------------------------------------
# Mostra o andamento de execu√ß√£o de cada target (status e tempo total).
tar_progress()
# 12. Resumo geral do pipeline -------------------------------------------------
# Exibe uma vis√£o resumida com n√∫mero de targets, tempo total e status geral.
tar_progress_summary()
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# -------------------------------------------------------------------
# Configura√ß√£o inicial e carregamento dos pacotes
# -------------------------------------------------------------------
library(targets)
library(tidyverse)
library(ggplot2)
library(ggpubr)
library(readxl)
library(knitr)
library(kableExtra)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
# Importa os resultados j√° processados pelo pipeline
estimativas <- tar_read(estimativas)
# 3. Ver manifesto do pipeline -------------------------------------------------
# Exibe o nome de cada target e o comando usado para ger√°-lo.
tar_manifest(fields = command)
# 6. Carregar target no ambiente do RStudio -----------------------------------
# Disponibiliza o objeto para uso manual, como se tivesse sido criado no script.
tar_load(relatorio_html)
View(relatorio_html)
# ---------------------------------------------------------------------
# 4. DEFINI√á√ÉO DOS TARGETS ---------------------------------------------
# ---------------------------------------------------------------------
list(
# Etapa 1: Coleta de dados via API GitHub ----------------------------
tar_target(
dados_brutos,
coleta_dados_github(
repo = "JenniferLopes/portfolio_experimentacao_agricola",
path = "meu_projeto/dados/alpha_lattice.xlsx"
)
),
# Etapa 2: Ajuste de vari√°veis ---------------------------------------
tar_target(
dados,
dados_brutos %>%
mutate(
gen = as.factor(gen),
rep = as.factor(rep),
inc.bloco = as.factor(inc.bloco)
)
),
# Etapa 3: Modelos BLUE e BLUP ---------------------------------------
tar_target(
modelo_BLUE,
lmer(prod ~ gen + rep + (1 | rep:inc.bloco), data = dados)
),
tar_target(
modelo_BLUP,
lmer(prod ~ rep + (1 | gen) + (1 | rep:inc.bloco), data = dados)
),
# Etapa 4: Estimativas BLUEs e BLUPs ---------------------------------
tar_target(
estimativas,
{
BLUEs <- emmeans(modelo_BLUE, ~ gen) %>%
as.data.frame() %>%
transmute(gen, BLUE = emmean)
mu_manual <- fixef(modelo_BLUP)[1]
BLUPs <- augment(ranef(modelo_BLUP)) %>%
filter(grp == "gen") %>%
transmute(gen = level, BLUP = mu_manual + estimate)
merge(BLUEs, BLUPs, by = "gen")
}
),
# Etapa 5: Herdabilidade ---------------------------------------------
tar_target(
herdabilidade,
{
vcomps <- as.data.frame(VarCorr(modelo_BLUP))
vc.g <- vcomps[vcomps$grp == "gen", "vcov"]
vc.e <- vcomps[vcomps$grp == "Residual", "vcov"]
nreps <- 3
hc <- vc.g / (vc.g + vc.e / nreps)
hc
}
),
# Etapa 6: Agrupamento UPGMA -----------------------------------------
tar_target(
agrupamento,
{
blup_values <- estimativas$BLUP
names(blup_values) <- estimativas$gen
hc <- hclust(dist(blup_values), method = "average")
hc
}
),
# Etapa 7: Gr√°fico BLUE vs BLUP --------------------------------------
tar_target(
grafico_BLUE_BLUP,
{
stopifnot(all(c("BLUE", "BLUP") %in% names(estimativas)))
ggplot(estimativas, aes(x = BLUE, y = BLUP)) +
geom_point(size = 3, alpha = 0.6, color = "#224573") +
geom_smooth(method = "lm", color = "#E85D04", se = FALSE) +
ggpubr::stat_regline_equation(label.y = max(estimativas$BLUP, na.rm = TRUE)) +
theme_bw() +
labs(
title = "Correla√ß√£o entre BLUEs e BLUPs dos Gen√≥tipos",
subtitle = "Estimativas ajustadas do modelo misto (REML)",
x = "BLUE (Efeito Fixo)",
y = "BLUP (Efeito Aleat√≥rio)",
caption = "SIGM | Jennifer Luz Lopes"
) +
theme(
plot.title = element_text(face = "bold", size = 13),
axis.text.x = element_text(angle = 45, hjust = 1)
)
}
),
# Etapa 8: Resumo final ----------------------------------------------
tar_target(
resumo_final,
{
tibble(
Herdabilidade = round(herdabilidade, 3),
Cor_BLUE_BLUP = cor(estimativas$BLUE, estimativas$BLUP)
)
}
),
# Etapa 9: Exporta√ß√£o autom√°tica -------------------------------------
tar_target(
exportar_resultados,
{
dir.create("meu_projeto/output", showWarnings = FALSE)
# Exporta tabela
writexl::write_xlsx(
list(
"Estimativas_BLUE_BLUP" = estimativas,
"Resumo_Final" = resumo_final
),
path = "meu_projeto/output/resultados_experimentais.xlsx"
)
# Exporta gr√°fico
ggsave(
filename = "meu_projeto/output/grafico_BLUE_BLUP.png",
plot = grafico_BLUE_BLUP,
width = 7,
height = 5,
dpi = 300
)
message("‚úÖ Resultados exportados para 'meu_projeto/output/'.")
},
cue = tar_cue(mode = "always")
),
# Etapa 10: Renderiza√ß√£o autom√°tica do relat√≥rio ---------------------
tar_target(
relatorio_html,
{
# Executa o Quarto como comando do sistema
system("quarto render meu_projeto/scripts/relatorio_experimental.qmd", intern = TRUE)
message("üìÑ Relat√≥rio HTML gerado com sucesso!")
"meu_projeto/scripts/relatorio_experimental.html"
},
cue = tar_cue(mode = "always")
)
)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
browseURL("meu_projeto/output/relatorio_experimental.html")
browseURL("meu_projeto/output/relatorio_experimental.html")
system("quarto render meu_projeto/scripts/relatorio_experimental.qmd", intern = TRUE)
list.files("meu_projeto/scripts", pattern = "html$", full.names = TRUE)
system("quarto render meu_projeto/scripts/relatorio_experimental.qmd --output meu_projeto/output/relatorio_experimental.html", intern = TRUE)
list.files("meu_projeto/scripts", pattern = "html$", full.names = TRUE)
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
browseURL("meu_projeto/output/relatorio_experimental.html")
# 2. Executar o pipeline completo ---------------------------------------------
# Reexecuta apenas as etapas (targets) que foram alteradas.
tar_make()
fs::dir_tree(here::here())       # Visualiza toda a √°rvore de diret√≥rios
